<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æˆ¦å¡µã®ãƒ¬ã‚¬ã‚¹ãƒˆãƒªã‚¢ï¼šæœ€çµ‚æˆ¦äº‰é›†è¨ˆãƒ„ãƒ¼ãƒ« v17</title>
  <style>
    :root{
      --bd:#ddd;
      --muted:#666;
      --shadow: 0 10px 24px rgba(0,0,0,.06);

      --central:#ff4d4d;      /* èµ¤ */
      --southriver:#a855f7;   /* ç´« */
      --northland:#67c8ff;    /* æ°´è‰² */
      --kaneka:#ffd84d;       /* é»„è‰² */
      --gray:#9aa0a6;         /* ç° */

      --atk:#ff4d4d;
      --def:#3b82f6;          /* é˜²è¡›ã‚²ãƒ¼ã‚¸ï¼šé’ */
    }

    body{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN",Meiragyo,sans-serif;
      margin:18px; line-height:1.35; background:#fafafa;
    }
    h1{font-size:18px;margin:0 0 10px;}
    h2{font-size:15px;margin:14px 0 8px;}
    .muted{color:var(--muted); font-size:12px;}
    .card{
      border:1px solid var(--bd); border-radius:14px; padding:12px; margin:10px 0;
      max-width:1700px; background:#fff; box-shadow: var(--shadow);
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button,input,select{font:inherit;}
    input[type="number"]{width:110px;}
    button{border:1px solid var(--bd); background:#fff; padding:8px 10px; border-radius:12px; cursor:pointer;}
    button:hover{background:#f6f6f6;}
    button.primary{background:#111; color:#fff; border-color:#111;}
    button.primary:hover{background:#222;}
    button.warn{background:#fff6f6; border-color:#ffb3b3;}
    button.warn:hover{background:#ffecec;}
    .layout{display:grid; grid-template-columns: 420px 1fr; gap:12px; max-width:1700px;}
    @media (max-width: 1200px){ .layout{grid-template-columns:1fr;} }

    .list{
      display:flex; flex-direction:column; gap:8px;
      max-height:64vh; overflow:auto; padding-right:4px;
    }

    .itemCard{
      border:1px solid var(--bd); border-radius:12px;
      padding:10px 10px 10px 18px;
      background:white;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      cursor:grab; user-select:none; position:relative;
    }
    .itemCard.nodrag{ cursor:default; }
    .itemCard:active{cursor:grabbing;}
    .itemCard.nodrag:active{cursor:default;}
    .itemCard.disabled{ opacity:.55; filter:grayscale(.25); }
    .left{min-width:0; flex:1;}
    .name{font-weight:900;}
    .value{font-weight:900; text-align:right;}
    .tiny{font-size:12px;}
    .inline{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;}

    .itemCard::before{
      content:""; position:absolute; left:0; top:0; bottom:0; width:10px;
      border-radius:12px 0 0 12px; background:var(--gray);
    }

    .itemCard.compact{ padding:6px 8px 6px 18px; gap:8px; }
    .itemCard.compact .name{font-size:12px;}
    .itemCard.compact .value{font-size:14px;}
    .itemCard.compact .muted.tiny{display:none;}
    .itemCard.compact .inline.tiny{display:none;}
    .itemCard.compact details{display:block; margin-top:6px;}
    .itemCard.compact details summary{cursor:pointer; font-size:12px; color:var(--muted);}
    .itemCard.compact details .inline.tiny{display:flex;}

    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px; border:1px solid var(--bd);
      font-size:12px; background:#fff;
    }
    .dot{width:10px; height:10px; border-radius:999px; background:var(--gray); display:inline-block;}
    .pill{
      display:inline-block; padding:2px 10px; border-radius:999px;
      border:1px solid var(--bd); font-size:12px; background:#fff;
    }

    .dropZone{
      border:2px dashed #d6d6d6; border-radius:14px; background:#fcfcfc;
      padding:10px;
    }
    .dropZoneHeader{
      display:flex; justify-content:space-between; align-items:baseline; gap:8px;
      margin-bottom:8px;
    }
    .dropZoneTitle{font-weight:900;}
    .dropOver{outline:3px solid #7aa7ff55; background:#f2f7ff;}

    .board{display:grid; grid-template-columns:1fr 1fr; gap:12px;}
    @media (max-width: 1200px){ .board{grid-template-columns:1fr;} }

    .fieldCard{
      border:1px solid var(--bd); border-radius:16px; padding:12px; background:white; box-shadow: var(--shadow);
      position:relative; overflow:hidden;
    }
    .fieldHeader{display:flex; flex-direction:column; gap:10px; margin-bottom:10px;}
    .fieldTitleRow{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .fieldTitle{font-weight:1000; font-size:16px; display:flex; align-items:center; gap:8px;}
    .fieldBadge{width:12px; height:12px; border-radius:999px; display:inline-block; background:var(--gray);}

    .resultBanner{
      border-radius:14px;
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border:1px solid var(--bd);
      background: linear-gradient(90deg, rgba(0,0,0,.03), rgba(0,0,0,.00));
    }
    .winner{font-weight:1100; font-size:16px;}
    .scoreLine{font-size:12px; color:var(--muted);}
    .bigScore{
      font-size:22px; font-weight:1100; letter-spacing:.5px;
      display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;
    }
    .bigScore span{white-space:nowrap;}

    .laneGrid{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .lane{
      border:1px dashed #d7d7d7; border-radius:14px; padding:10px;
      min-height:160px; background:#fafafa;
    }
    .laneTitle{display:flex; justify-content:space-between; align-items:baseline; gap:8px; margin-bottom:6px; font-weight:900;}
    .laneTotals{display:flex; gap:6px; flex-wrap:wrap; align-items:center; font-size:12px;}
    .dropHint{font-size:12px; color:var(--muted); margin-top:2px;}
    .laneList{margin-top:8px; display:flex; flex-direction:column; gap:6px;}
    details{margin-top:8px;}

    .tint-central{border-left:10px solid var(--central);}
    .tint-southriver{border-left:10px solid var(--southriver);}
    .tint-northland{border-left:10px solid var(--northland);}
    .tint-kaneka{border-left:10px solid var(--kaneka);}

    .c-central::before{background:var(--central);}
    .c-southriver::before{background:var(--southriver);}
    .c-northland::before{background:var(--northland);}
    .c-kaneka::before{background:var(--kaneka);}
    .c-gray::before{background:var(--gray);}

    .dot.central{background:var(--central);}
    .dot.southriver{background:var(--southriver);}
    .dot.northland{background:var(--northland);}
    .dot.kaneka{background:var(--kaneka);}
    .dot.gray{background:var(--gray);}

    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 900px){ .grid2{grid-template-columns:1fr;} }

    .occupyBox{
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
      padding:8px 10px; border:1px solid var(--bd); border-radius:12px; background:#fff;
    }
    .occupyLabel{font-weight:900;}
    .log{
      max-height:160px; overflow:auto; border:1px solid var(--bd); border-radius:12px;
      padding:8px; background:#fff;
      font-size:12px; color:#333;
    }
    .logLine{margin:0 0 6px;}
    .logLine:last-child{margin:0;}

    .checkGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:6px 10px;
      align-items:center;
    }
    @media (max-width: 520px){ .checkGrid{grid-template-columns:1fr;} }
    .miniBox{
      border:1px solid var(--bd);
      border-radius:12px;
      padding:8px;
      background:#fff;
    }

    /* === æˆ¦æœå ±å‘Šãƒ¢ãƒ¼ãƒ€ãƒ«UIï¼ˆæ¨ªä¸¦ã³4æšï¼‰ === */
    .overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
      z-index: 999;
      display: flex; align-items: center; justify-content: center;
      padding: 18px;
      overflow:auto;
    }
    .resultModal {
      background: #fff; padding: 16px; border-radius: 16px;
      width: min(1600px, 100%);
      max-height: calc(100vh - 36px);
      overflow:auto;
      box-shadow: 0 20px 50px rgba(0,0,0,0.3);
      animation: slideUp 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    @keyframes slideUp { from{transform:translateY(18px);opacity:0;} to{transform:translateY(0);opacity:1;} }

    .res-title { text-align: center; font-size: 20px; margin: 0 0 10px; border-bottom: 2px solid #eee; padding-bottom: 10px; }

    /* 4æšæ¨ªä¸¦ã³ï¼ˆç‹­ã„ç”»é¢ã¯æŠ˜ã‚Šè¿”ã—ï¼‰ */
    .res-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(260px, 1fr));
      gap: 12px;
      align-items: start;
    }
    @media (max-width: 1400px){ .res-grid { grid-template-columns: repeat(2, minmax(260px, 1fr)); } }
    @media (max-width: 760px){ .res-grid { grid-template-columns: 1fr; } }

    .res-card {
      border: 1px solid #ddd; border-radius: 14px; padding: 12px;
      position: relative; overflow: hidden; background: #fafafa;
    }
    .res-card.atk-win { border: 2px solid var(--atk); background: #fff5f5; }
    .res-card.def-win { border: 2px solid var(--def); background: #f3f7ff; }

    .res-header { display: flex; justify-content: space-between; align-items: center; font-weight: 900; font-size: 14px; margin-bottom: 8px; gap:10px; flex-wrap:wrap;}
    .res-scores { display: flex; justify-content: center; align-items: baseline; gap: 10px; font-size: 18px; font-weight: 1100; margin: 6px 0; }
    .res-vs { font-size: 12px; color: #999; font-weight: normal; }

    /* å‹æ•—ã‚²ãƒ¼ã‚¸ */
    .gaugeWrap{
      border:1px solid #e5e5e5; border-radius:999px; overflow:hidden;
      height:14px; background:#fff;
      display:flex;
      margin-top:10px;
    }
    .gAtk, .gDef{
      height:100%;
      width:0%;
    }
    .gAtk{ background: linear-gradient(90deg, rgba(255,77,77,.35), rgba(255,77,77,1)); }
    .gDef{ background: linear-gradient(90deg, rgba(59,130,246,.35), rgba(59,130,246,1)); }

    .gLabelRow{
      margin-top:6px;
      display:flex; justify-content:space-between; gap:10px;
      font-size:12px; color:#333;
    }
    .gLabelRow b{font-weight:1100;}
    .gMini{ font-size:11px; color:var(--muted); margin-top:4px; }

    .stamp {
      position: absolute; right: -10px; bottom: -5px;
      font-size: 30px; font-weight: 1100; opacity: 0.14;
      transform: rotate(-12deg); pointer-events: none;
    }
    .st-win { color: var(--atk); }
    .st-lose { color: var(--def); }

    .res-alert {
      background: #ffd700; color: #000; font-weight: 1000; font-size: 12px;
      text-align: center; padding: 6px; border-radius: 10px; margin-top: 10px;
      animation: pulse 1.8s infinite;
    }
    @keyframes pulse { 0%{opacity:1;} 50%{opacity:0.65;} 100%{opacity:1;} }

    .res-ribbon{
      margin-top:10px;
      border-radius:12px;
      padding:8px 10px;
      font-weight:1100;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid #e5e5e5;
      background:#fff;
    }
    .res-ribbon.atk{ border-color: rgba(255,77,77,.35); background: rgba(255,77,77,.08); }
    .res-ribbon.def{ border-color: rgba(59,130,246,.35); background: rgba(59,130,246,.08); }

    .res-sideLists{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 520px){ .res-sideLists{grid-template-columns:1fr;} }

    .res-sideBox{
      border:1px solid #e6e6e6;
      border-radius:12px;
      background:#fff;
      padding:8px;
    }
    .res-sideBox .t{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      font-weight:1100; font-size:12px;
      margin-bottom:6px;
    }
    .res-sideBox.atk .t{ color: var(--atk); }
    .res-sideBox.def .t{ color: var(--def); }
    .res-line{
      font-size:12px;
      display:flex; justify-content:space-between; gap:10px;
      border-top:1px dashed #eee;
      padding-top:6px; margin-top:6px;
    }
    .res-line:first-child{ border-top:none; padding-top:0; margin-top:0; }
    .res-line .nm{ min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .res-line .pv{ font-weight:1100; }

    .res-footer { margin-top: 14px; text-align: center; }
    .res-news { font-size: 13px; color: #333; margin-bottom: 12px; text-align: left; background: #f2f2f2; padding: 10px; border-radius: 12px; }
    .newsBlock{ margin:0 0 8px; }
    .newsBlock:last-child{ margin:0; }

    .newsBoom{
      border:2px solid #ff4d4d55;
      background: #fff5f5;
      border-radius:12px;
      padding:10px;
      margin-top:10px;
    }
    .newsBoom .hd{ font-weight:1100; color:#c00; margin-bottom:6px; }
    .newsBoom .li{ font-size:12px; margin:0 0 6px; }
    .newsBoom .li:last-child{ margin:0; }

    .newsSab{
      border:2px solid rgba(168,85,247,.35);
      background: rgba(168,85,247,.08);
      border-radius:12px;
      padding:10px;
      margin-top:10px;
    }
    .newsSab .hd{ font-weight:1100; color:#6d28d9; margin-bottom:6px; }
    .newsSab .li{ font-size:12px; margin:0 0 6px; }
    .newsSab .li:last-child{ margin:0; }

    /* å‹ã£ãŸå´ã‚²ãƒ¼ã‚¸ã‚’ä¸€ç¬ä¼¸ã°ã™ */
    @keyframes winStretch { from{transform:scaleX(.86);} to{transform:scaleX(1);} }
    .winStretch { transform-origin:left; animation: winStretch .35s ease; }
    .winStretchRight { transform-origin:right; animation: winStretch .35s ease; }
  </style>
</head>
<body>
  <h1>æˆ¦å¡µã®ãƒ¬ã‚¬ã‚¹ãƒˆãƒªã‚¢ï¼šæˆ¦äº‰é›†è¨ˆãƒ„ãƒ¼ãƒ« v17ï¼ˆãƒªã‚¶ãƒ«ãƒˆæ¨ªä¸¦ã³4æšï¼‰</h1>
  <div class="muted">
    âœ… å¿ èª å¿ƒã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ0ã€‚<b>å¿ èª å¿ƒãŒ20å¢—æ¸›ã™ã‚‹ãŸã³ã«å…µåŠ›ãŒ10å¢—æ¸›</b>ï¼ˆå¢—ï¼šå›å¾©ï¼æ¸›ï¼šè„±èµ°ï¼‰<br/>
    âœ… ã€Œå¿ èª å¿ƒå¤‰å‹•â†’å…µåŠ›å¢—æ¸›ã€ã¯<b>æˆ¦äº‰æ±ºç€å‰ã«åæ˜ </b>ã—ã¾ã™ï¼ˆæ”¯æ´ãƒ»è‡ªç”±ã®åŒå¿—å¢—åŠ ãƒ»ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼æˆ¦é—˜æ™‚-10ï¼‰<br/>
    âœ… <b>ã‚­ãƒ£ãƒ©ã¯Round3ã®ã¿å‚æˆ¦å¯èƒ½</b>ï¼ˆRound1/2ã¯ã‚­ãƒ£ãƒ©é…ç½®ãƒ»ã‚­ãƒ£ãƒ©ã‚¹ã‚­ãƒ«ãƒ»æ”¯æ´åŠ¹æœã™ã¹ã¦ç„¡åŠ¹ï¼‰<br/>
  </div>

  <div class="card">
    <div class="row">
      <div class="pill"><b>æˆ¦äº‰ãƒ©ã‚¦ãƒ³ãƒ‰ï¼š</b> <span id="roundText" class="mono"></span></div>
      <button id="btnFinalizeRound" class="primary">ã“ã®æˆ¦äº‰ã‚’ç¢ºå®šï¼ˆå¿ èª å¿ƒâ†’å…µåŠ›å¢—æ¸›â†’å‹æ•—â†’å¿ èª å¿ƒâ†’å…µåŠ›å¢—æ¸›ï¼å æ‹ æ›´æ–°ç­‰ï¼‰</button>
      <button id="btnPrevRound">â†å‰ã®æˆ¦äº‰ã¸</button>
      <button id="btnNextRound">æ¬¡ã®æˆ¦äº‰ã¸â†’</button>
    </div>
    <div class="grid2" style="margin-top:10px;">
      <div class="occupyBox">
        <span class="occupyLabel">ç¾åœ¨ã®å æ‹ è€…ï¼ˆGMç·¨é›†å¯ï¼‰ï¼š</span>

        <span class="pill">ã‚»ãƒ³ãƒˆãƒ©ãƒ«ï¼š <select id="occCentralSel"></select></span>
        <span class="pill">ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼ï¼š <select id="occSouthSel"></select></span>
        <span class="pill">ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰ï¼š <select id="occNorthSel"></select></span>
        <span class="pill">é‡‘è¯ï¼š <select id="occKanekaSel"></select></span>
      </div>
      <div>
        <div class="muted" style="margin-bottom:6px;">ç¢ºå®šãƒ­ã‚°ï¼ˆä¸ŠãŒæœ€æ–°ï¼‰</div>
        <div id="logBox" class="log"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="muted">
        åŸå£ï¼šé€šå¸¸ +30ï¼ˆã‚»ãƒ³ãƒˆãƒ©ãƒ« +100ã€å…­èŠ’æ˜Ÿã§0ï¼‰ / åŒå€¤ã¯é˜²è¡›å‹ã¡
      </div>
      <div style="margin-left:auto" class="row">
        <button id="btnClearChars">ã‚­ãƒ£ãƒ©é…ç½®ã‚¯ãƒªã‚¢</button>
        <button id="btnClearArmies">è»é…ç½®ã‚¯ãƒªã‚¢</button>
        <button id="btnResetAll" class="warn">å…¨ãƒ‡ãƒ¼ã‚¿æ¶ˆå»</button>
      </div>
    </div>
  </div>

  <div class="layout">
    <div>
      <div class="card dropZone" id="armyWaitingZone">
        <div class="dropZoneHeader">
          <div>
            <div class="dropZoneTitle">å¾…æ©Ÿï¼šè»æœ¬ä½“ï¼ˆä¸å‚åŠ ï¼‰</div>
            <div class="muted">ã“ã“ã¸ãƒ‰ãƒ­ãƒƒãƒ—ã§ã€Œä¸å‚åŠ ã€ã«æˆ»ã‚‹</div>
          </div>
          <div class="muted">ãƒ‰ãƒ©ãƒƒã‚°å¯</div>
        </div>
        <div id="armyList" class="list"></div>
      </div>

      <div class="card dropZone" id="charWaitingZone">
        <div class="dropZoneHeader">
          <div>
            <div class="dropZoneTitle">å¾…æ©Ÿï¼šã‚­ãƒ£ãƒ©ï¼ˆä¸å‚åŠ ï¼‰</div>
            <div class="muted" id="charWaitingHint"></div>
          </div>
          <div class="muted">Round3ã®ã¿ãƒ‰ãƒ©ãƒƒã‚°å¯</div>
        </div>
        <div id="charList" class="list"></div>
      </div>
    </div>

    <div class="card">
      <h2>æˆ¦å ´ãƒœãƒ¼ãƒ‰ï¼ˆæ”»æ’ƒ/é˜²è¡›ã¸ãƒ‰ãƒ­ãƒƒãƒ—ï¼‰</h2>
      <div id="board" class="board" style="margin-top:10px;"></div>
    </div>
  </div>

  <div id="resultOverlay" class="overlay" style="display:none;">
    <div class="resultModal" id="resultModalRoot">
      <h2 class="res-title">æˆ¦æœå ±å‘Šæ›¸ï¼šRound <span id="resRoundNum"></span></h2>
      <div id="resGrid" class="res-grid"></div>

      <div class="res-footer">
        <div id="resNews" class="res-news"></div>
        <div class="row" style="justify-content:center;">
          <button id="btnSaveResultHtml">çµæœã‚’HTMLä¿å­˜</button>
          <button onclick="closeResult()" class="primary">é–‰ã˜ã‚‹</button>
        </div>
        <div class="muted" style="margin-top:8px;">â€»ã€ŒHTMLä¿å­˜ã€ã¯ã€è¡¨ç¤ºä¸­ã®æˆ¦æœå ±å‘Šæ›¸ã‚’1æšã®HTMLã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</div>
      </div>
    </div>
  </div>

<script>
/* ========= constants ========= */
const STORAGE_KEY = "regastria_war_tool_v17";

/* ---- armies ---- */
const ARMIES = [
  "ç‹å®¤é¨å£«å›£","ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£","ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ","åŒ—éƒ¨è²´æ—é€£åˆæ®‹å…š",
  "é‡‘è¯å‚­å…µå›£","é‡‘è¯å…¬å®¶è»","ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ","ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š","ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"
];
const ACTIVE_FIELDS = ["ã‚»ãƒ³ãƒˆãƒ©ãƒ«","ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼","ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰","é‡‘è¯"];
const FIELD_LABEL = { "ã‚»ãƒ³ãƒˆãƒ©ãƒ«":"ã‚»ãƒ³ãƒˆãƒ©ãƒ«", "ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼":"ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼", "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰":"ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰", "é‡‘è¯":"é‡‘è¯å…¬å›½" };
const SIDES = ["æ”»æ’ƒ","é˜²è¡›"];
const MAX_ROUNDS = 3;

/* ---- colors ---- */
const COLOR = {
  central: { key:"central", label:"èµ¤", cssClass:"c-central" },
  southriver:{ key:"southriver", label:"ç´«", cssClass:"c-southriver" },
  northland:{ key:"northland", label:"æ°´è‰²", cssClass:"c-northland" },
  kaneka:{ key:"kaneka", label:"é»„è‰²", cssClass:"c-kaneka" },
  gray:{ key:"gray", label:"ç°", cssClass:"c-gray" },
};
const FIELD_TO_COLORKEY = {
  "ã‚»ãƒ³ãƒˆãƒ©ãƒ«":"central",
  "ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼":"southriver",
  "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰":"northland",
  "é‡‘è¯":"kaneka",
};

/* Army color binding */
const ARMY_COLORKEY = {
  "ç‹å®¤é¨å£«å›£":"central",
  "ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£":"southriver",
  "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ":"northland",
  "åŒ—éƒ¨è²´æ—é€£åˆæ®‹å…š":"northland",
  "é‡‘è¯å‚­å…µå›£":"kaneka",
  "é‡‘è¯å…¬å®¶è»":"kaneka",
  "ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ":"gray",
  "ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—":"gray",
  "ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š":"gray",
};

/* å¿ èª å¿ƒ åˆæœŸå€¤ï¼šå…¨éƒ¨0 */
const DEFAULT_LOYALTY = {};

/* è‡ªç”±ã®åŒå¿—å¢—åŠ ã§ä¸‹ãŒã‚‹é‡ï¼ˆ1äººã«ã¤ãï¼‰ */
function loyaltyDropPerMember(armyName){
  if(["ç‹å®¤é¨å£«å›£","ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£","ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ","é‡‘è¯å‚­å…µå›£"].includes(armyName)) return 10;
  return 5;
}

/* ========= characters =========
   supportOnly=true ã®ã‚­ãƒ£ãƒ©ã¯ã€Œå€‹äººå…µåŠ›0ã€ã ãŒã€å‚æˆ¦ï¼ˆRound3ã§é…ç½®ï¼‰ã—ã¦ã„ã‚Œã°æ”¯æ´åŠ¹æœãŒç™ºå‹•ã™ã‚‹
*/
const CHAR_PRESETS = [
  { id:"maria", name:"ãƒãƒªã‚¢", colorKey:"central", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šå‰ç·šæŒ‡æ®ï¼ˆå€‹äºº+10ï¼‰"}],
    basePersonal:()=>10
  },
  { id:"lion", name:"ãƒªã‚ªãƒ³", colorKey:"central", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€ŒæŒ‡å®šè»ã®å¿ èª å¿ƒ +40ï¼ˆæ°¸ç¶šï¼å…µåŠ›å¢—æ¸›ã¯æ±ºç€å‰ã«åæ˜ ï¼‰ã€"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },
  { id:"serin", name:"ã‚»ãƒªãƒ³", colorKey:"central", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€ŒæŒ‡å®šè»ã®å¿ èª å¿ƒ -40ï¼ˆæ°¸ç¶šï¼‰ã€ï¼ã“ã®åŠ¹æœã§æ¸›ã£ãŸå…µåŠ›ã¯ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ã¸åˆæµï¼ˆæ±ºç€å‰ã«åæ˜ ï¼‰"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },
  { id:"gail", name:"ã‚²ã‚¤ãƒ«", colorKey:"central", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šè‹±é›„ã®å‡ºæ’ƒï¼ˆå€‹äºº+30ï¼‰"}],
    basePersonal:()=>30
  },

  { id:"karuna", name:"ã‚«ãƒ«ãƒ¼ãƒŠ", colorKey:"southriver", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šå¥³å‚‘ã®å‡ºæ’ƒï¼ˆå€‹äºº+30ï¼‰"}],
    basePersonal:()=>30
  },
  { id:"noelis", name:"ãƒã‚¨ãƒªã‚¹", colorKey:"southriver", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€ŒæŒ‡å®šè»ã®å¿ èª å¿ƒ +40ï¼ˆæ°¸ç¶šï¼å…µåŠ›å¢—æ¸›ã¯æ±ºç€å‰ã«åæ˜ ï¼‰ã€"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },
  { id:"emil", name:"ã‚¨ãƒŸãƒ¼ãƒ«", colorKey:"southriver", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šé»’ã®éŒ¬é‡‘è¡“ï¼ˆåŒæˆ¦å ´ã®æ•µè»ã™ã¹ã¦-20ï¼æˆ¦é—˜ä¸­ã®ã¿ï¼‰â€»Round3ã®ã¿"}],
    basePersonal:()=>0
  },
  { id:"helena", name:"ãƒ˜ãƒ¬ãƒŠ", colorKey:"southriver", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šé¨å£«ã®å‡ºæ’ƒï¼ˆå€‹äºº+20ï¼‰"}],
    basePersonal:()=>20
  },

  { id:"rito", name:"ãƒªãƒˆ", colorKey:"northland", supportOnly:false,
    extraSchema:[
      {type:"label", text:"å‡ºæ’ƒï¼šæ°·ç«œé¡•ç¾ï¼ˆå€‹äºº+100 / å®Œå…¨é¡•ç¾+300ï¼‰"},
      {type:"checkbox", key:"ritoFull", label:"å®Œå…¨é¡•ç¾ï¼ˆ+300ï¼‰"}
    ],
    basePersonal:(meta)=> meta.flags?.ritoFull ? 300 : 100
  },
  { id:"rata", name:"ãƒ©ã‚¿", colorKey:"northland", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šç«ç«œé¡•ç¾ï¼ˆå€‹äºº+40ï¼‰"}],
    basePersonal:()=>40
  },
  { id:"ruri", name:"ãƒ«ãƒª", colorKey:"northland", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šæ ¼é—˜æŠ€ï¼ˆå€‹äºº+10ï¼‰"}],
    basePersonal:()=>10
  },
  { id:"seno", name:"ã‚»ãƒ", colorKey:"northland", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€Œå¯¾è±¡è»ã®å¿ èª å¿ƒ -20ï¼ˆæ°¸ç¶šï¼å…µåŠ›å¢—æ¸›ã¯æ±ºç€å‰ã«åæ˜ ï¼‰ã€"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },

  { id:"gentoku", name:"ç„å¾³", colorKey:"kaneka", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€Œæ”¯æ‰•Ã—5 ã‚’å¯¾è±¡è»ã«åŠ ç®—ï¼ˆã“ã®æˆ¦é—˜ã®ã¿ï¼‰ã€"},
      {type:"payx5", key:"pay", label:"æ”¯æ‰•é¡ï¼ˆÃ—5ï¼‰", min:0},
      {type:"targetArmy", key:"targetArmy", label:"å¼·åŒ–ã™ã‚‹è»"}
    ],
  },
  { id:"ryusei", name:"æµæ˜Ÿ", colorKey:"kaneka", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šæ§ã®åæ‰‹ï¼ˆå€‹äºº+20ï¼‰"}],
    basePersonal:()=>20
  },
  { id:"suiran", name:"ç¿ åµ", colorKey:"kaneka", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€Œå¯¾è±¡è» å…µåŠ›+30ï¼ˆæˆ¦é—˜ã®ã¿ï¼‰ï¼å¿ èª å¿ƒ+20ï¼ˆæ°¸ç¶šï¼‰ã€"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },
  { id:"il", name:"ã‚¤ãƒ«", colorKey:"kaneka", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€Œå¯¾è±¡è»ã®å¿ èª å¿ƒ -40ï¼ˆæ°¸ç¶šï¼å…µåŠ›å¢—æ¸›ã¯æ±ºç€å‰ã«åæ˜ ï¼‰ã€"},
      {type:"targetArmy", key:"targetArmy", label:"å¯¾è±¡è»"}
    ],
  },
  { id:"yuris", name:"ãƒ¦ãƒªã‚¹", colorKey:"gray", supportOnly:true,
    extraSchema:[{type:"label", text:"æ”¯æ´ï¼šè‡´æ­»æ¯’æ··å…¥ï¼ˆã‚»ãƒ³ãƒˆãƒ©ãƒ«é˜²è¡›å´ã§å‚æˆ¦ä¸­ã®ã¿ã€ã‚»ãƒ³ãƒˆãƒ©ãƒ«é˜²è¡›å´ã®å„è» å…µåŠ›-10ï¼æˆ¦é—˜ã®ã¿ï¼‰"}],
  },
  { id:"lorentz", name:"ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„", colorKey:"gray", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šãƒãƒ¯ãƒ¼ãƒ«ã®é¨å£«ï¼ˆå€‹äºº+20ï¼‰"}],
    basePersonal:()=>20
  },
  { id:"reni", name:"ãƒ¬ãƒ‹", colorKey:"gray", supportOnly:false,
    extraSchema:[{type:"label", text:"å‡ºæ’ƒï¼šé¢¨ç«œé¡•ç¾ï¼ˆå€‹äºº+60ï¼‰"}],
    basePersonal:()=>60
  },
  { id:"sebastian", name:"ã‚»ãƒã‚¹ãƒãƒ£ãƒ³", colorKey:"gray", supportOnly:true,
    extraSchema:[
      {type:"label", text:"æ”¯æ´ï¼šå‚æˆ¦ä¸­ã®ã¿ã€Œæ”¯æ‰•Ã—5 ã‚’å¯¾è±¡è»ã«åŠ ç®—ï¼ˆã“ã®æˆ¦é—˜ã®ã¿ï¼‰ã€"},
      {type:"payx5", key:"pay", label:"æ”¯æ‰•é¡ï¼ˆÃ—5ï¼‰", min:0},
      {type:"targetArmy", key:"targetArmy", label:"å¼·åŒ–ã™ã‚‹è»"}
    ],
  },
];

function allPeopleList(){ return CHAR_PRESETS.map(p=>({ id:p.id, name:p.name })); }

/* ========= state ========= */
const state = { roundIndex: 1, occupation: {}, rounds: {}, armiesMeta: {}, charsMeta: {}, log: [] };

/* ========= utils ========= */
const el = (id)=>document.getElementById(id);
const escapeHtml = (s)=>String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function cssEscape(s){ return String(s).replace(/"/g,'\\"'); }
function isRound3(){ return state.roundIndex === 3; }
function isCharParticipating(charId, round){ if(round !== 3) return false; return !!state.rounds[round].chars[charId]?.placed; }
const monoTs = ()=>{ const d=new Date(); const pad=(n)=>String(n).padStart(2,"0"); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };
function colorTagHtml(colorKey){ const key = colorKey || "gray"; return `<span class="tag"><span class="dot ${key}"></span>${escapeHtml(COLOR[key].label)}</span>`; }
function cardColorClass(colorKey){ const key = colorKey || "gray"; return COLOR[key].cssClass; }

/* ========= persistence ========= */
function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

function initRoundIfMissing(r){
  if(!state.rounds[r]) state.rounds[r] = { armies:{}, chars:{}, fieldFlags:{} };
  state.rounds[r].armies ||= {};
  state.rounds[r].chars ||= {};
  state.rounds[r].fieldFlags ||= {};
  if(typeof state.rounds[r].fieldFlags.centralWallOff !== "boolean") state.rounds[r].fieldFlags.centralWallOff = false;

  for(const a of ARMIES){
    state.rounds[r].armies[a] ||= { placed:null };
    if(!("placed" in state.rounds[r].armies[a])) state.rounds[r].armies[a].placed = null;
  }
  for(const p of CHAR_PRESETS){
    state.rounds[r].chars[p.id] ||= { placed:null };
    if(!("placed" in state.rounds[r].chars[p.id])) state.rounds[r].chars[p.id].placed = null;
  }
}

function initDefaults(){
  state.roundIndex = 1;
  state.occupation = { "ã‚»ãƒ³ãƒˆãƒ©ãƒ«":"ç‹å®¤é¨å£«å›£", "ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼":"ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£", "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰":"ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ", "é‡‘è¯":"é‡‘è¯å‚­å…µå›£" };
  state.rounds = {};
  for(let r=1;r<=MAX_ROUNDS;r++) initRoundIfMissing(r);

  state.armiesMeta = {};
  for(const a of ARMIES){
    state.armiesMeta[a] = { flags:{}, params:{}, delta:0 };
    state.armiesMeta[a].params.loyalty = 0;
    state.armiesMeta[a].params.chaosMode ||= "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
  }
  state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers = ["seno"];
  state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.prevLibCount = 1;

  state.charsMeta = {};
  for(const p of CHAR_PRESETS){
    state.charsMeta[p.id] = { flags:{}, extra:{ pay:0, targetArmy:"" } };
  }

  state.log = [];
}

function load(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw){ initDefaults(); return; }
  try{
    const obj = JSON.parse(raw);
    if(!obj || !obj.roundIndex || !obj.occupation || !obj.rounds || !obj.armiesMeta || !obj.charsMeta){
      initDefaults(); return;
    }
    Object.assign(state, obj);

    for(let r=1;r<=MAX_ROUNDS;r++) initRoundIfMissing(r);

    for(const a of ARMIES){
      if(!state.armiesMeta[a]) state.armiesMeta[a] = { flags:{}, params:{}, delta:0 };
      state.armiesMeta[a].flags ||= {};
      state.armiesMeta[a].params ||= {};
      if(typeof state.armiesMeta[a].delta !== "number") state.armiesMeta[a].delta = 0;

      if(typeof state.armiesMeta[a].params.loyalty !== "number") state.armiesMeta[a].params.loyalty = 0;
      if(a==="ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ" && !state.armiesMeta[a].params.chaosMode) state.armiesMeta[a].params.chaosMode = "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
    }

    for(const p of CHAR_PRESETS){
      if(!state.charsMeta[p.id]) state.charsMeta[p.id] = { flags:{}, extra:{ pay:0, targetArmy:"" } };
      state.charsMeta[p.id].flags ||= {};
      state.charsMeta[p.id].extra ||= { pay:0, targetArmy:"" };
      if(typeof state.charsMeta[p.id].extra.pay !== "number") state.charsMeta[p.id].extra.pay = Number(state.charsMeta[p.id].extra.pay||0);
      if(typeof state.charsMeta[p.id].extra.targetArmy !== "string") state.charsMeta[p.id].extra.targetArmy = "";
    }

    if(!state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"]) state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"] = { flags:{}, params:{}, delta:0 };
    state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params ||= {};
    if(!Array.isArray(state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers)){
      state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers = ["seno"];
    }else if(state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers.length===0){
      state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers = ["seno"];
    }
    if(typeof state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.prevLibCount !== "number"){
      state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.prevLibCount = state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers.length;
    }

    state.log ||= [];
  }catch(_){ initDefaults(); }
}

/* ========= GMå æ‹ æ‰‹å‹•å¤‰æ›´ ========= */
function buildOccSelect(selectEl, fieldName){
  const options = [...ARMIES, ...CHAR_PRESETS.map(p=>p.name)];
  selectEl.innerHTML = "";
  for(const name of options){
    const o = document.createElement("option");
    o.value = name; o.textContent = name;
    selectEl.appendChild(o);
  }
  const cur = state.occupation[fieldName] || "";
  selectEl.value = options.includes(cur) ? cur : (options[0] || "");
  selectEl.onchange = ()=>{ state.occupation[fieldName] = selectEl.value; save(); renderAll(); };
}

/* ========= wall bonusï¼ˆå¸¸ã«å­˜åœ¨ï¼‰ ========= */
function wallBonus(field, round){
  if(field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«"){
    const off = !!state.rounds[round].fieldFlags.centralWallOff;
    return off ? 0 : 100;
  }
  return 30;
}

/* ========= army base + current ========= */
function calcArmyBaseRaw(armyName){
  switch(armyName){
    case "ç‹å®¤é¨å£«å›£": return 90;
    case "ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£": return 100;
    case "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ": return 50;
    case "åŒ—éƒ¨è²´æ—é€£åˆæ®‹å…š": return 30;
    case "é‡‘è¯å‚­å…µå›£": return 60;
    case "é‡‘è¯å…¬å®¶è»": return 50;
    case "ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ": return 30;
    case "ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š": return 30;
    case "ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—":{
      const members = state.armiesMeta[armyName]?.params?.libMembers || [];
      return 10 * Math.max(0, members.length);
    }
    default: return 0;
  }
}
function getArmyCurrentBase(armyName){
  const base = calcArmyBaseRaw(armyName);
  const delta = Number(state.armiesMeta[armyName]?.delta || 0);
  return base + delta;
}
function setArmyCurrentBase(armyName, desired){
  const base = calcArmyBaseRaw(armyName);
  state.armiesMeta[armyName].delta = Number(desired) - base;
}

/* snapshot for cross-army conditions */
function makeSnapshot(round){
  const set = new Set();
  return { add:(a,f,s)=>set.add(`${a}||${f}||${s}`), has:(a,f,s)=>set.has(`${a}||${f}||${s}`) };
}

/* ========= display nameï¼ˆçµæœç”»é¢ã§ã‚±ã‚¤ã‚ªã‚¹ç ´å£Šå·¥ä½œã¯æ­£ä½“ä¸æ˜ï¼‰ ========= */
function getArmyDisplayName(name, round, forResult){
  if(!forResult) return name;
  if(name==="ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ"){
    const mode = state.armiesMeta[name]?.params?.chaosMode || "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
    if(mode==="ç ´å£Šå·¥ä½œãƒ¢ãƒ¼ãƒ‰") return "æ­£ä½“ä¸æ˜ã®è»";
  }
  return name;
}

/* ========= support effects (Round3 & participating only) ========= */
function getSupportPowerBonusMap(round){
  const bonus = {}; for(const a of ARMIES) bonus[a]=0;
  if(round !== 3) return bonus;

  const meta = state.charsMeta;

  // ç„å¾³
  if(isCharParticipating("gentoku", round)){
    const pay = Math.max(0, Number(meta["gentoku"]?.extra?.pay||0));
    const t = meta["gentoku"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) bonus[t] += pay*5;
  }

  // ç¿ åµï¼ˆå…µåŠ›+30ã¯æˆ¦é—˜ã®ã¿ï¼‰
  if(isCharParticipating("suiran", round)){
    const t = meta["suiran"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) bonus[t] += 30;
  }

  // ãƒ¦ãƒªã‚¹ï¼šã‚»ãƒ³ãƒˆãƒ©ãƒ«é˜²è¡›å´ã§å‚æˆ¦ã—ã¦ã„ã‚‹æ™‚ã€ã‚»ãƒ³ãƒˆãƒ©ãƒ«é˜²è¡›å´ã®å„è»ã‚’-10ï¼ˆæˆ¦é—˜ã®ã¿ï¼‰
  if(isCharParticipating("yuris", round)){
    const yPlaced = state.rounds[round].chars["yuris"]?.placed;
    if(yPlaced && yPlaced.field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«" && yPlaced.side==="é˜²è¡›"){
      for(const a of ARMIES){
        const p = state.rounds[round].armies[a]?.placed;
        if(p && p.field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«" && p.side==="é˜²è¡›"){
          bonus[a] -= 10;
        }
      }
    }
  }

  // ã‚»ãƒã‚¹ãƒãƒ£ãƒ³
  if(isCharParticipating("sebastian", round)){
    const pay = Math.max(0, Number(meta["sebastian"]?.extra?.pay||0));
    const t = meta["sebastian"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) bonus[t] += pay*5;
  }

  return bonus;
}

function getSupportLoyaltyDeltaList(round){
  const deltas = [];
  if(round !== 3) return deltas;

  const meta = state.charsMeta;

  // ç¿ åµï¼šå¿ èª å¿ƒ +20
  if(isCharParticipating("suiran", round)){
    const t = meta["suiran"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:+20, reason:"ç¿ åµ(+20)"});
  }

  // ã‚¤ãƒ«ï¼šå¿ èª å¿ƒ -20ï¼ˆ-40ã§ã¯ãªã-20ï¼‰
  if(isCharParticipating("il", round)){
    const t = meta["il"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:-20, reason:"ã‚¤ãƒ«(-20)"});
  }

  // ã‚»ãƒï¼šå¿ èª å¿ƒ -20 ï¼† ã“ã®åŠ¹æœã§æ¸›ã£ãŸå…µåŠ›ã‚’ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ã«åŠ ç®—
  if(isCharParticipating("seno", round)){
    const t = meta["seno"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:-20, reason:"ã‚»ãƒ(-20)", transferTo:"ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"});
  }

  // ãƒªã‚ªãƒ³ï¼šå¿ èª å¿ƒ +40
  if(isCharParticipating("lion", round)){
    const t = meta["lion"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:+40, reason:"ãƒªã‚ªãƒ³(+40)"});
  }

  // ãƒã‚¨ãƒªã‚¹ï¼šæŒ‡å®šè» å¿ èª å¿ƒ +40ï¼ˆãƒªã‚ªãƒ³ã¨åŒã˜ï¼‰
  if(isCharParticipating("noelis", round)){
    const t = meta["noelis"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:+40, reason:"ãƒã‚¨ãƒªã‚¹(+40)"});
  }

  // ã‚»ãƒªãƒ³ï¼šæŒ‡å®šè» å¿ èª å¿ƒ -40 ï¼† ã“ã®åŠ¹æœã§æ¸›ã£ãŸå…µåŠ›ã‚’ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ã«åŠ ç®—
  if(isCharParticipating("serin", round)){
    const t = meta["serin"]?.extra?.targetArmy || "";
    if(ARMIES.includes(t)) deltas.push({army:t, delta:-40, reason:"ã‚»ãƒªãƒ³(-40)", transferTo:"ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"});
  }

  return deltas;
}

/* ========= Emil effect (Round3 only) ========= */
function emilDebuffForArmy(armyName, round){
  if(round !== 3) return 0;
  const emilPlaced = state.rounds[round].chars["emil"]?.placed;
  if(!emilPlaced) return 0;

  const aPlaced = state.rounds[round].armies[armyName]?.placed;
  if(!aPlaced) return 0;

  if(aPlaced.field !== emilPlaced.field) return 0;
  if(aPlaced.side === emilPlaced.side) return 0;

  return -20;
}

/* ========= Dragon presence (Round3 only) ========= */
const DRAGON_IDS = ["rito","rata","reni"];
function hasEnemyDragonInField(field, side, round){
  if(round !== 3) return false;
  for(const id of DRAGON_IDS){
    const p = state.rounds[round].chars[id]?.placed;
    if(!p) continue;
    if(p.field===field && p.side!==side) return true;
  }
  return false;
}

/* ========= army modifier logic ========= */
function armyModifier(armyName, snap, round, supportPowerBonus){
  const placed = state.rounds[round].armies[armyName].placed;
  if(!placed) return 0;

  const field = placed.field;
  const side  = placed.side;
  const enemySide = (side==="æ”»æ’ƒ") ? "é˜²è¡›" : "æ”»æ’ƒ";

  let mod = 0;

  switch(armyName){
    case "ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£": mod += snap.has("ç‹å®¤é¨å£«å›£", field, enemySide) ? 30 : 0; break;
    case "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ": mod += (field==="ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰") ? 30 : 0; break;
    case "åŒ—éƒ¨è²´æ—é€£åˆæ®‹å…š": mod += hasEnemyDragonInField(field, side, round) ? 40 : 0; break;
    case "é‡‘è¯å‚­å…µå›£": mod += (side==="æ”»æ’ƒ") ? 30 : 0; break;
    case "é‡‘è¯å…¬å®¶è»": mod += (state.occupation["é‡‘è¯"] === "é‡‘è¯å…¬å®¶è»") ? 30 : 0; break;
    case "ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š": mod += state.armiesMeta[armyName].flags?.noirHexagram ? 50 : 0; break;
    case "ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ":{
      const mode = state.armiesMeta[armyName].params?.chaosMode || "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
      if(mode==="ç ´å£Šå·¥ä½œãƒ¢ãƒ¼ãƒ‰"){ mod += -getArmyCurrentBase("ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ"); }
      break;
    }
  }

  mod += (supportPowerBonus?.[armyName] || 0);
  mod += emilDebuffForArmy(armyName, round);

  return mod;
}

function calcArmyPower(armyName, snap, round, supportPowerBonus){
  const baseCurrent = getArmyCurrentBase(armyName);
  const mod = armyModifier(armyName, snap, round, supportPowerBonus);
  const value = Math.max(0, baseCurrent + mod);
  return { baseCurrent, mod, value };
}

/* ========= personal power ========= */
function calcPersonalPower(preset){
  const meta = state.charsMeta[preset.id];
  if(preset.supportOnly) return 0;
  const fn = preset.basePersonal || (()=>0);
  return Number(fn(meta)||0);
}

/* ========= compute totals for current round ========= */
function compute(round){
  const snap = makeSnapshot(round);
  for(const name of ARMIES){
    const placed = state.rounds[round].armies[name].placed;
    if(placed) snap.add(name, placed.field, placed.side);
  }

  const supportPowerBonus = getSupportPowerBonusMap(round);

  const totals = {};
  for(const f of ACTIVE_FIELDS){
    totals[f] = { atk:{army:0, personal:0, armyBreak:[], personalBreak:[]}, def:{army:0, personal:0, armyBreak:[], personalBreak:[]} };
  }

  for(const name of ARMIES){
    const placed = state.rounds[round].armies[name].placed;
    if(!placed) continue;
    const bucket = (placed.side==="æ”»æ’ƒ") ? "atk" : "def";
    const { baseCurrent, mod, value } = calcArmyPower(name, snap, round, supportPowerBonus);
    totals[placed.field][bucket].army += value;
    totals[placed.field][bucket].armyBreak.push({ name, baseCurrent, mod, value });
  }

  if(round === 3){
    for(const preset of CHAR_PRESETS){
      const placed = state.rounds[round].chars[preset.id].placed;
      if(!placed) continue;

      const bucket = (placed.side==="æ”»æ’ƒ") ? "atk" : "def";
      if(preset.supportOnly){
        totals[placed.field][bucket].personalBreak.push({ id:preset.id, name:`${preset.name}(æ”¯æ´)`, value:0 });
        continue;
      }
      const p = calcPersonalPower(preset);
      totals[placed.field][bucket].personal += p;
      totals[placed.field][bucket].personalBreak.push({ id:preset.id, name:preset.name, value:p });
    }
  }

  const results = ACTIVE_FIELDS.map(field=>{
    const atkTotal = totals[field].atk.army + totals[field].atk.personal;
    const defBase  = totals[field].def.army + totals[field].def.personal;
    const bonus = wallBonus(field, round);
    const defTotal = defBase + bonus;
    const winner = (atkTotal > defTotal) ? "æ”»æ’ƒå´ã®å‹åˆ©" : "é˜²è¡›å´ã®å‹åˆ©ï¼ˆåŒå€¤å«ã‚€ï¼‰";
    return { field, atkTotal, defBase, bonus, defTotal, winner, attackWon:(atkTotal>defTotal) };
  });

  return { totals, results, snap, supportPowerBonus };
}

/* ========= loyalty -> troop change (20åˆ»ã¿ã§Â±10) ========= */
function step20(x){
  return Math.trunc(Number(x || 0) / 20);
}

function applyLoyaltyDelta(army, delta, reason, transferTo=null){
  const meta = state.armiesMeta[army];
  if(!meta) return [];

  const before = Number(meta.params?.loyalty ?? 0);
  const after  = before + delta;
  meta.params.loyalty = after;

  const logs = [`å¿ èª å¿ƒï¼š${army} ${before}â†’${after}ï¼ˆ${reason}ï¼‰`];

  const bStep = step20(before);
  const aStep = step20(after);
  const diff = aStep - bStep;

  if(diff !== 0){
    // diff * 10 ãŒã€Œã“ã®è»ã®å…µåŠ›å¢—æ¸›é‡ã€
    const troopDelta = diff * 10;

    // å¯¾è±¡è»ã®å…µåŠ›åæ˜ 
    const cur = getArmyCurrentBase(army);
    const next = Math.max(0, cur + troopDelta);
    setArmyCurrentBase(army, next);

    if(troopDelta > 0){
      logs.push(`âœ¨å…µåŠ›å›å¾©ï¼š${army} +${troopDelta}ï¼ˆ${cur}â†’${next}ï¼‰`);
    }else{
      logs.push(`ğŸ’¥è„±èµ°ï¼š${army} ${(-troopDelta)}ï¼ˆ${cur}â†’${next}ï¼‰`);
    }

    // ã€Œæ¸›ã£ãŸå…µåŠ›ã‚’åˆ¥è»ã¸åˆæµã€ï¼štroopDelta ãŒãƒã‚¤ãƒŠã‚¹ã®æ™‚ã ã‘
    if(transferTo && troopDelta < 0 && state.armiesMeta[transferTo]){
      const gain = -troopDelta;
      const cur2 = getArmyCurrentBase(transferTo);
      const next2 = Math.max(0, cur2 + gain);
      setArmyCurrentBase(transferTo, next2);

      // å…µåŠ›å›å¾©ã®ãƒ­ã‚°å½¢å¼ã«ã—ã¦ãŠãã¨ã€çµæœç”»é¢ã®ã€Œâœ¨å…µåŠ›å›å¾©ã€æ ã«è¼‰ã‚‹
      // logs.push(`âœ¨å…µåŠ›å›å¾©ï¼š${transferTo} +${gain}ï¼ˆ${cur2}â†’${next2}ï¼‰`);
      logs.push(`ğŸª½åˆæµï¼š${army} ã‹ã‚‰é›¢è„±ã—ãŸå…µ ${gain} ãŒ ${transferTo} ã«å¸åã•ã‚ŒãŸ`);
    }
  }

  return logs;
}

/* ========= Liberator battle-time loyalty debuff ========= */
function applyLiberatorBattleDebuff(round){
  const logs = [];
  const lib = "ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—";
  const pLib = state.rounds[round].armies[lib]?.placed;
  if(!pLib) return logs;

  const field = pLib.field;
  const enemySide = (pLib.side==="æ”»æ’ƒ") ? "é˜²è¡›" : "æ”»æ’ƒ";

  let hit = 0;
  for(const a of ARMIES){
    if(a===lib) continue;
    const p = state.rounds[round].armies[a]?.placed;
    if(!p) continue;
    if(p.field===field && p.side===enemySide){
      logs.push(...applyLoyaltyDelta(
        a,
        -10,
        `ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ï¼ˆæˆ¦é—˜æ™‚-10ï¼‰@${field}`,
        "ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"   // â†ã“ã®è„±èµ°ã ã‘åˆæµ
      ));
      hit++;
    }
  }
  if(hit===0) logs.push(`ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ï¼ˆæˆ¦é—˜æ™‚-10ï¼‰ï¼š${field} ã®æ•µè»ãŒã„ãªã„ãŸã‚ä¸ç™º`);
  return logs;
}

/* ========= pre-battle loyalty changes ========= */
function applyPreBattleLoyaltyChanges(round){
  const logs = [];

  const lib = state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params;
  const nowCount = (lib.libMembers || []).length;
  const prevCount = Number(lib.prevLibCount ?? nowCount);
  const diff = nowCount - prevCount;

  if(diff > 0){
    logs.push(`ğŸ•Šï¸è‡ªç”±ã®åŒå¿—ï¼š${diff}äººãŒãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—ã«åˆæµï¼ˆåç°¿å¢—åŠ ï¼å…µåŠ›+${diff*10}ï¼‰`);

    for(const a of ARMIES){
      if(a==="ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—") continue;
      const drop = loyaltyDropPerMember(a) * diff;
      logs.push(...applyLoyaltyDelta(a, -drop, `è‡ªç”±ã®åŒå¿—å¢—åŠ (${diff}äºº)`));
    }
    lib.prevLibCount = nowCount;
  }else{
    lib.prevLibCount = nowCount;
  }

  const deltas = getSupportLoyaltyDeltaList(round);
  if(deltas.length){
    for(const d of deltas){
      logs.push(...applyLoyaltyDelta(d.army, d.delta, d.reason, d.transferTo || null));
    }
  }else{
    logs.push("å¿ èª å¿ƒï¼ˆæ”¯æ´ï¼‰ï¼šå¤‰åŒ–ãªã—ï¼ˆRound3ä»¥å¤–ï¼æœªå‚æˆ¦ï¼å¯¾è±¡æœªé¸æŠãªã©ï¼‰");
  }

  logs.push(...applyLiberatorBattleDebuff(round));
  return logs;
}

/* ========= post-battle loyalty changes ========= */
function applyOutcomeLoyaltyChanges(round, results){
  const logs = [];
  for(const res of results){
    const attackWon = (res.atkTotal > res.defTotal);
    if(!attackWon) continue;
    const field = res.field;

    for(const a of ARMIES){
      const p = state.rounds[round].armies[a].placed;
      if(p && p.field===field && p.side==="æ”»æ’ƒ") logs.push(...applyLoyaltyDelta(a, +10, `${field} æ”»æ’ƒå‹åˆ©(+10)`));
    }
    for(const a of ARMIES){
      const p = state.rounds[round].armies[a].placed;
      if(p && p.field===field && p.side==="é˜²è¡›") logs.push(...applyLoyaltyDelta(a, -10, `${field} é˜²è¡›æ•—åŒ—(-10)`));
    }
  }
  if(!logs.length) logs.push("å¿ èª å¿ƒï¼ˆå‹æ•—ï¼‰ï¼šå¤‰åŒ–ãªã—ï¼ˆæ”»æ’ƒå‹åˆ©ãŒãªã„ï¼‰");
  return logs;
}

/* ========= chaos sabotage (after war, does NOT affect this battle) ========= */
function applyChaosSabotageAfterWar(round, snap, supportPowerBonus){
  const chaos = "ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ";
  const placed = state.rounds[round].armies[chaos].placed;
  const mode = state.armiesMeta[chaos].params?.chaosMode || "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
  if(!placed || mode!=="ç ´å£Šå·¥ä½œãƒ¢ãƒ¼ãƒ‰") return [];

  const field = placed.field;
  const enemySide = (placed.side==="æ”»æ’ƒ") ? "é˜²è¡›" : "æ”»æ’ƒ";

  const enemies = [];
  for(const name of ARMIES){
    if(name===chaos) continue;
    const p = state.rounds[round].armies[name].placed;
    if(!p) continue;
    if(p.field!==field || p.side!==enemySide) continue;

    const { value } = calcArmyPower(name, snap, round, supportPowerBonus);
    enemies.push({ name, value });
  }
  if(!enemies.length) return [`ç ´å£Šå·¥ä½œï¼š${field} æ•µå´ã«è»ãŒã„ãªã„ãŸã‚ä¸ç™º`];

  const maxVal = Math.max(...enemies.map(x=>x.value));
  const maxOnes = enemies.filter(x=>x.value===maxVal);
  const target = randPick(maxOnes).name;

  const cur = getArmyCurrentBase(target);
  const next = Math.max(0, cur - 20);
  setArmyCurrentBase(target, next);

  return [`ğŸ’£ç ´å£Šå·¥ä½œï¼š${field} ã®æ•µæœ€å¤§è»ã€Œ${target}ã€ã‚’æ’ä¹…-20ï¼ˆ${cur}â†’${next}ï¼‰`];
}

/* ========= occupation update ========= */
function updateOccupationFromAttackWinners(round, snap, supportPowerBonus){
  const { results } = compute(round);
  const changes = [];

  for(const r of results){
    if(!(r.atkTotal > r.defTotal)) continue;

    const entities = [];

    for(const a of ARMIES){
      const placed = state.rounds[round].armies[a].placed;
      if(!placed) continue;
      if(placed.field !== r.field) continue;
      if(placed.side !== "æ”»æ’ƒ") continue;

      const { value } = calcArmyPower(a, snap, round, supportPowerBonus);
      entities.push({ name:a, value, kind:"army" });
    }

    if(round === 3){
      for(const p of CHAR_PRESETS){
        const placed = state.rounds[round].chars[p.id].placed;
        if(!placed) continue;
        if(placed.field !== r.field) continue;
        if(placed.side !== "æ”»æ’ƒ") continue;

        const val = p.supportOnly ? 0 : calcPersonalPower(p);
        entities.push({ name:p.name, value:val, kind:"person" });
      }
    }

    if(!entities.length) continue;

    const maxVal = Math.max(...entities.map(x=>x.value));
    const maxOnes = entities.filter(x=>x.value===maxVal);
    const chosen = randPick(maxOnes).name;

    const prev = state.occupation[r.field];
    if(prev !== chosen){
      state.occupation[r.field] = chosen;
      changes.push(`å æ‹ æ›´æ–°ï¼š${r.field} ${prev} â†’ ${chosen}ï¼ˆæœ€å¤§å…µåŠ› ${maxVal}ï¼‰`);
    }else{
      changes.push(`å æ‹ ç¶­æŒï¼š${r.field} ${prev}ï¼ˆæœ€å¤§å…µåŠ› ${maxVal}ï¼‰`);
    }
  }
  return changes;
}

/* ========= drag & drop ========= */
let dragPayload = null;

function onDragStart(e, payload){
  dragPayload = payload;
  e.dataTransfer.setData("text/plain", JSON.stringify(payload));
  e.dataTransfer.effectAllowed = "move";
}

function enableDropZone(zoneEl, onDropFn){
  zoneEl.addEventListener("dragover",(e)=>{
    e.preventDefault();
    zoneEl.classList.add("dropOver");
    e.dataTransfer.dropEffect="move";
  });
  zoneEl.addEventListener("dragleave", ()=> zoneEl.classList.remove("dropOver"));
  zoneEl.addEventListener("drop",(e)=>{
    e.preventDefault();
    zoneEl.classList.remove("dropOver");
    let payload=null;
    try{ payload=JSON.parse(e.dataTransfer.getData("text/plain")||""); }catch(_){}
    payload=payload||dragPayload;
    if(!payload) return;
    onDropFn(payload);
    save(); renderAll();
  });
}

function enableLaneDrop(lane){
  enableDropZone(lane, (payload)=>{
    const round = state.roundIndex;
    const field = lane.dataset.field;
    const side  = lane.dataset.side;

    if(payload.type==="char"){
      if(round !== 3) return;
      state.rounds[round].chars[payload.id].placed = { field, side };
    } else if(payload.type==="army"){
      state.rounds[round].armies[payload.name].placed = { field, side };
    }
  });
}

/* ========= render: extras ========= */
function armyExtraHint(name){
  if(name==="é‡‘è¯å…¬å®¶è»") return "é‡‘è¯å æ‹ ãŒé‡‘è¯å…¬å®¶è»ãªã‚‰+30ï¼ˆè‡ªå‹•ï¼‰";
  if(name==="ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š") return "å…­èŠ’æ˜Ÿè§£æ”¾ã§+50";
  if(name==="ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—") return "å…µåŠ›=10Ã—ï¼ˆåç°¿ã®äººæ•°ï¼‰ï¼æˆ¦é—˜æ™‚ï¼šåŒæˆ¦å ´ã®æ•µè»ã®å¿ èª å¿ƒ-10";
  if(name==="ç‹å®¤é¨å£«å›£") return "æ•µã«ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆãŒã„ã‚‹æˆ¦å ´ã§+30";
  if(name==="ã‚¢ãƒ¡ã‚¸ã‚¹ãƒˆé­”è¡“å¸«å›£") return "æ•µã«ç‹å®¤ãŒã„ã‚‹æˆ¦å ´ã§+30";
  if(name==="ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰å¼“å…µéšŠ") return "æˆ¦å ´ãŒãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰ã§+30";
  if(name==="åŒ—éƒ¨è²´æ—é€£åˆæ®‹å…š") return "æ•µã«ç«œï¼ˆãƒªãƒˆ/ãƒ©ã‚¿/ãƒ¬ãƒ‹ï¼‰ãŒã„ã‚‹æˆ¦å ´ã§+40";
  if(name==="é‡‘è¯å‚­å…µå›£") return "æ”»æ’ƒå´ãªã‚‰+30";
  if(name==="ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ") return "ç ´å£Šå·¥ä½œãƒ¢ãƒ¼ãƒ‰ï¼šæˆ¦é—˜ä¸­0ï¼‹æˆ¦å¾Œã«æ•µæœ€å¤§è»ã¸æ’ä¹…-20ï¼ˆçµæœç”»é¢ã§ã¯æ­£ä½“ä¸æ˜ã®è»ï¼‰";
  return "-";
}

function renderLiberatorMemberPicker(){
  const members = state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers || [];
  const box = document.createElement("div");
  box.className = "miniBox";

  const title = document.createElement("div");
  title.className = "tiny";
  title.innerHTML = `<b>è‡ªç”±ã®åŒå¿— åç°¿</b>ï¼ˆå…µåŠ›=10Ã—äººæ•°ï¼‰`;
  box.appendChild(title);

  const grid = document.createElement("div");
  grid.className = "checkGrid";
  const people = allPeopleList();

  for(const p of people){
    const label = document.createElement("label");
    label.className = "inline tiny";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = members.includes(p.id);

    cb.addEventListener("change", ()=>{
      let next = new Set(state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers || []);
      if(cb.checked) next.add(p.id);
      else next.delete(p.id);
      state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.libMembers = Array.from(next);
      save(); renderAll();
    });

    label.appendChild(cb);
    label.appendChild(document.createTextNode(" " + p.name));
    grid.appendChild(label);
  }

  box.appendChild(grid);

  const line = document.createElement("div");
  line.className="muted tiny";
  const names = people.filter(p=>members.includes(p.id)).map(p=>p.name);
  line.textContent = `ç¾åœ¨ï¼š${names.length ? names.join("ã€") : "ï¼ˆãªã—ï¼‰"}ï¼ˆprev=${state.armiesMeta["ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"].params.prevLibCount ?? names.length}ï¼‰`;
  box.appendChild(line);

  return box;
}

function renderArmyExtrasInputs(name){
  const meta = state.armiesMeta[name];
  const wrap = document.createElement("div");
  wrap.className="inline tiny";

  const baseRaw = calcArmyBaseRaw(name);
  const cur = getArmyCurrentBase(name);

  const gmBox = document.createElement("span");
  gmBox.className = "pill";
  gmBox.innerHTML = `GMç¾åœ¨å…µåŠ›`;
  const inp = document.createElement("input");
  inp.type="number";
  inp.value = cur;
  inp.title = `åŸºç¤(${baseRaw}) + å·®åˆ†(delta=${meta.delta}) = ç¾åœ¨å…µåŠ›`;
  inp.addEventListener("change", ()=>{
    setArmyCurrentBase(name, Number(inp.value||0));
    save(); renderAll();
  });
  gmBox.appendChild(inp);
  wrap.appendChild(gmBox);

  const loyBox = document.createElement("span");
  loyBox.className="pill";
  loyBox.innerHTML = `å¿ èª å¿ƒ`;
  const loy = document.createElement("input");
  loy.type="number";
  loy.value = Number(meta.params?.loyalty ?? 0);
  loy.addEventListener("change", ()=>{
    meta.params.loyalty = Number(loy.value||0);
    save(); renderAll();
  });
  loyBox.appendChild(loy);
  wrap.appendChild(loyBox);

  const stepPill = document.createElement("span");
  stepPill.className="pill";
  stepPill.textContent = `æ®µï¼ˆå¿ èª å¿ƒ/20ï¼‰ï¼š${step20(Number(meta.params?.loyalty ?? 0))}`;
  wrap.appendChild(stepPill);

  if(name==="ãƒãƒ¯ãƒ¼ãƒ«é¨é¦¬éšŠæ®‹å…š"){
    const label=document.createElement("label"); label.className="inline tiny";
    const cb=document.createElement("input"); cb.type="checkbox"; cb.checked=!!meta.flags.noirHexagram;
    cb.addEventListener("change", ()=>{ meta.flags.noirHexagram=cb.checked; save(); renderAll(); });
    label.appendChild(cb); label.appendChild(document.createTextNode(" å…­èŠ’æ˜Ÿè§£æ”¾"));
    wrap.appendChild(label);
  }

  if(name==="ãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—"){
    wrap.appendChild(renderLiberatorMemberPicker());
  }

  if(name==="ã‚±ã‚¤ã‚ªã‚¹é ˜ç§å…µ"){
    const sel=document.createElement("select");
    ["æˆ¦ãƒ¢ãƒ¼ãƒ‰","ç ´å£Šå·¥ä½œãƒ¢ãƒ¼ãƒ‰"].forEach(x=>{
      const o=document.createElement("option"); o.value=x; o.textContent=x; sel.appendChild(o);
    });
    sel.value = meta.params.chaosMode || "æˆ¦ãƒ¢ãƒ¼ãƒ‰";
    sel.addEventListener("change", ()=>{ meta.params.chaosMode=sel.value; save(); renderAll(); });
    wrap.appendChild(sel);
  }

  const resetBtn = document.createElement("button");
  resetBtn.textContent="å…µåŠ›ãƒªã‚»ãƒƒãƒˆ";
  resetBtn.title="ã“ã®è»ã®å·®åˆ†(delta)ã‚’0ã«æˆ»ã™";
  resetBtn.addEventListener("click", ()=>{
    meta.delta = 0; save(); renderAll();
  });
  wrap.appendChild(resetBtn);

  return wrap;
}

function renderArmyTargetSelect(charId){
  const meta = state.charsMeta[charId];
  const sel=document.createElement("select");
  const blank=document.createElement("option");
  blank.value=""; blank.textContent="ï¼ˆæœªé¸æŠï¼‰";
  sel.appendChild(blank);

  for(const a of ARMIES){
    const o=document.createElement("option");
    o.value=a; o.textContent=a;
    sel.appendChild(o);
  }
  sel.value = meta.extra?.targetArmy || "";
  sel.addEventListener("change", ()=>{ meta.extra.targetArmy = sel.value; save(); renderAll(); });
  return sel;
}

function renderCharExtrasInputs(preset){
  const meta = state.charsMeta[preset.id];
  const wrap=document.createElement("div");
  wrap.className="inline tiny";

  for(const item of (preset.extraSchema||[])){
    if(item.type==="checkbox"){
      const l=document.createElement("label"); l.className="inline tiny";
      const c=document.createElement("input"); c.type="checkbox"; c.checked=!!meta.flags[item.key];
      c.addEventListener("change", ()=>{ meta.flags[item.key]=c.checked; save(); renderAll(); });
      l.appendChild(c); l.appendChild(document.createTextNode(" " + item.label));
      wrap.appendChild(l);
    }
    if(item.type==="payx5"){
      const n=document.createElement("input");
      n.type="number"; n.min=String(item.min ?? 0);
      n.value=Number(meta.extra?.pay||0);
      n.addEventListener("change", ()=>{ meta.extra.pay=Number(n.value||0); save(); renderAll(); });
      wrap.appendChild(document.createTextNode("æ”¯æ‰•"));
      wrap.appendChild(n);
      const hint=document.createElement("span"); hint.className="muted"; hint.textContent="Ã—5";
      wrap.appendChild(hint);
    }
    if(item.type==="targetArmy"){
      const lab=document.createElement("span"); lab.className="muted"; lab.textContent = item.label + "ï¼š";
      wrap.appendChild(lab);
      wrap.appendChild(renderArmyTargetSelect(preset.id));
    }
    if(item.type==="label"){
      const s=document.createElement("span"); s.className="muted"; s.textContent=item.text;
      wrap.appendChild(s);
    }
  }
  return wrap;
}

/* ========= render ========= */
function formatArmyBreakdown(arr){
  if(!arr?.length) return "ãªã—";
  return arr.map(x=>`${x.name}=${x.value}ï¼ˆç¾åœ¨${x.baseCurrent}${x.mod?` ${x.mod>=0?"+":""}${x.mod}`:""}ï¼‰`).join(" / ");
}
function formatPersonalBreakdown(arr){
  if(!arr?.length) return "ãªã—";
  return arr.map(x=>`${x.name}ï¼ˆ${x.value}ï¼‰`).join(" / ");
}

function renderTop(){
  el("roundText").textContent = `${state.roundIndex} / ${MAX_ROUNDS}`;
  buildOccSelect(el("occCentralSel"), "ã‚»ãƒ³ãƒˆãƒ©ãƒ«");
  buildOccSelect(el("occSouthSel"),   "ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼");
  buildOccSelect(el("occNorthSel"),   "ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰");
  buildOccSelect(el("occKanekaSel"),  "é‡‘è¯");

  el("charWaitingHint").textContent = (state.roundIndex===3)
    ? "ã“ã“ã‹ã‚‰æˆ¦å ´ã¸ãƒ‰ãƒ©ãƒƒã‚°ã§å‚æˆ¦ï¼ˆæ”¯æ´ã‚­ãƒ£ãƒ©ã‚‚å‚æˆ¦ãŒå¿…è¦ï¼‰ï¼å¾…æ©Ÿã¸æˆ»ã™ãªã‚‰ã“ã“ã¸ãƒ‰ãƒ­ãƒƒãƒ—"
    : "Round1/2ã§ã¯ã‚­ãƒ£ãƒ©ã¯å‚æˆ¦ã§ãã¾ã›ã‚“ï¼ˆé…ç½®ã—ã¦ã‚‚ç„¡åŠ¹ï¼‰ã€‚Round3ã§ã®ã¿æœ‰åŠ¹ã€‚";

  const box = el("logBox");
  box.innerHTML = "";
  if(!state.log.length){
    box.innerHTML = `<div class="muted">ï¼ˆã¾ã ç¢ºå®šãƒ­ã‚°ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰</div>`;
    return;
  }
  for(const item of state.log.slice(0,30)){
    const p = document.createElement("div");
    p.className="logLine";
    p.innerHTML = `<span class="muted">${escapeHtml(item.ts)}</span> â€” ${escapeHtml(item.text)}`;
    box.appendChild(p);
  }
}

function renderWaitingArmies(){
  const list = el("armyList");
  list.innerHTML="";
  const round = state.roundIndex;

  for(const name of ARMIES){
    const placed = state.rounds[round].armies[name].placed;
    if(placed) continue;

    const baseRaw = calcArmyBaseRaw(name);
    const cur = getArmyCurrentBase(name);
    const colorKey = ARMY_COLORKEY[name] || "gray";
    const loy = Number(state.armiesMeta[name].params?.loyalty ?? 0);

    const card=document.createElement("div");
    card.className = `itemCard ${cardColorClass(colorKey)}`;
    card.draggable=true;
    card.addEventListener("dragstart",(e)=>onDragStart(e,{type:"army", name}));

    card.innerHTML = `
      <div class="left">
        <div class="name">${escapeHtml(name)} ${colorTagHtml(colorKey)}</div>
        <div class="muted tiny">
          åŸºç¤ï¼š<b>${baseRaw}</b> ï¼ ç¾åœ¨ï¼š<b>${cur}</b>
          <span class="pill">delta ${state.armiesMeta[name].delta}</span>
          <span class="pill">å¿ èª å¿ƒ <b>${loy}</b></span>
          <span class="pill">æ®µ ${step20(loy)}</span>
        </div>
        <div class="muted tiny" style="margin-top:4px;">${escapeHtml(armyExtraHint(name))}</div>
        <div class="inline tiny" style="margin-top:8px;" id="armyExtras_${escapeHtml(name)}"></div>
      </div>
      <div class="value">${cur}</div>
    `;
    card.querySelector(`#armyExtras_${cssEscape(name)}`).appendChild(renderArmyExtrasInputs(name));
    list.appendChild(card);
  }

  if(!list.children.length){
    const p=document.createElement("div"); p.className="muted"; p.textContent="ï¼ˆå¾…æ©Ÿä¸­ã®è»ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰";
    list.appendChild(p);
  }
}

function renderWaitingChars(){
  const list = el("charList");
  list.innerHTML="";
  const round = state.roundIndex;
  const canDrag = (round === 3);

  for(const preset of CHAR_PRESETS){
    const placed = state.rounds[round].chars[preset.id].placed;
    if(placed) continue;

    const pwr = preset.supportOnly ? 0 : calcPersonalPower(preset);
    const colorKey = preset.colorKey || "gray";

    const card=document.createElement("div");
    card.className = `itemCard ${cardColorClass(colorKey)} ${canDrag ? "" : "nodrag disabled"}`;
    if(canDrag){
      card.draggable=true;
      card.addEventListener("dragstart",(e)=>onDragStart(e,{type:"char", id:preset.id}));
    }

    card.innerHTML = `
      <div class="left">
        <div class="name">${escapeHtml(preset.name)} ${colorTagHtml(colorKey)} ${preset.supportOnly?`<span class="pill">æ”¯æ´</span>`:""}</div>
        <div class="inline tiny" style="margin-top:8px;" id="charExtras_${escapeHtml(preset.id)}"></div>
      </div>
      <div class="value">
        <div class="muted tiny">${preset.supportOnly ? "å‚æˆ¦ã§æ”¯æ´ç™ºå‹•" : "å€‹äººå…µåŠ›"}</div>
        ${preset.supportOnly ? "0" : pwr}
      </div>
    `;
    card.querySelector(`#charExtras_${cssEscape(preset.id)}`).appendChild(renderCharExtrasInputs(preset));
    list.appendChild(card);
  }

  if(!list.children.length){
    const p=document.createElement("div"); p.className="muted"; p.textContent="ï¼ˆå¾…æ©Ÿä¸­ã®ã‚­ãƒ£ãƒ©ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰";
    list.appendChild(p);
  }
}

function renderPlacedArmies(field, side, snap, supportPowerBonus){
  const wrap=document.createElement("div");
  wrap.className="laneList";
  const round = state.roundIndex;

  for(const name of ARMIES){
    const placed = state.rounds[round].armies[name].placed;
    if(!placed) continue;
    if(placed.field!==field || placed.side!==side) continue;

    const colorKey = ARMY_COLORKEY[name] || "gray";
    const { value } = calcArmyPower(name, snap, round, supportPowerBonus);

    const card=document.createElement("div");
    card.className = `itemCard compact ${cardColorClass(colorKey)}`;
    card.draggable=true;
    card.addEventListener("dragstart",(e)=>onDragStart(e,{type:"army", name}));
    card.addEventListener("dblclick", ()=>{ state.rounds[round].armies[name].placed=null; save(); renderAll(); });

    card.innerHTML = `
      <div class="left">
        <div class="name">ã€è»ã€‘${escapeHtml(name)} ${colorTagHtml(colorKey)}</div>
        <details>
          <summary>ç·¨é›†ï¼ˆGMå…µåŠ›/å¿ èª å¿ƒ/ç‰¹æ®Šè¨­å®šï¼‰</summary>
          <div class="inline tiny" style="margin-top:8px;" id="armyPlacedExtras_${escapeHtml(name)}"></div>
          <div class="muted tiny" style="margin-top:6px;">${escapeHtml(armyExtraHint(name))}</div>
        </details>
      </div>
      <div class="value">${value}</div>
    `;
    card.querySelector(`#armyPlacedExtras_${cssEscape(name)}`).appendChild(renderArmyExtrasInputs(name));
    wrap.appendChild(card);
  }
  return wrap;
}

function renderPlacedChars(field, side){
  const wrap=document.createElement("div");
  wrap.className="laneList";
  const round = state.roundIndex;
  if(round !== 3) return wrap;

  for(const preset of CHAR_PRESETS){
    const placed = state.rounds[round].chars[preset.id].placed;
    if(!placed) continue;
    if(placed.field!==field || placed.side!==side) continue;

    const pwr = preset.supportOnly ? 0 : calcPersonalPower(preset);
    const colorKey = preset.colorKey || "gray";

    const card=document.createElement("div");
    card.className = `itemCard compact ${cardColorClass(colorKey)}`;
    card.draggable=true;
    card.addEventListener("dragstart",(e)=>onDragStart(e,{type:"char", id:preset.id}));
    card.addEventListener("dblclick", ()=>{ state.rounds[round].chars[preset.id].placed=null; save(); renderAll(); });

    card.innerHTML = `
      <div class="left">
        <div class="name">ã€å€‹ã€‘${escapeHtml(preset.name)} ${colorTagHtml(colorKey)} ${preset.supportOnly?`<span class="pill">æ”¯æ´</span>`:""}</div>
        <details>
          <summary>ç·¨é›†ï¼ˆã‚¹ã‚­ãƒ«è¨­å®šï¼‰</summary>
          <div class="inline tiny" style="margin-top:8px;" id="charPlacedExtras_${escapeHtml(preset.id)}"></div>
        </details>
      </div>
      <div class="value">${pwr}</div>
    `;
    card.querySelector(`#charPlacedExtras_${cssEscape(preset.id)}`).appendChild(renderCharExtrasInputs(preset));
    wrap.appendChild(card);
  }
  return wrap;
}

function renderBoard(){
  const board = el("board");
  board.innerHTML="";
  const round = state.roundIndex;
  const { totals, results, snap, supportPowerBonus } = compute(round);

  for(const field of ACTIVE_FIELDS){
    const r = results.find(x=>x.field===field);
    const fieldColorKey = FIELD_TO_COLORKEY[field];
    const tintClass =
      field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«" ? "tint-central" :
      field==="ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼" ? "tint-southriver" :
      field==="ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰" ? "tint-northland" :
      "tint-kaneka";

    const card=document.createElement("div");
    card.className = `fieldCard ${tintClass}`;

    const occ = state.occupation[field] || "-";

    card.innerHTML = `
      <div class="fieldHeader">
        <div class="fieldTitleRow">
          <div class="fieldTitle">
            <span class="fieldBadge" style="background: var(--${fieldColorKey});"></span>
            ${escapeHtml(FIELD_LABEL[field])}
            <span class="pill">å æ‹ ï¼š<b>${escapeHtml(occ)}</b></span>
          </div>
          <div class="pill mono">Round ${round}</div>
        </div>

        ${field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«" ? `
          <div class="inline tiny">
            <label class="inline tiny">
              <input type="checkbox" id="centralWallOff_${round}" ${state.rounds[round].fieldFlags.centralWallOff ? "checked":""}/>
              å…­èŠ’æ˜Ÿï¼šã‚»ãƒ³ãƒˆãƒ©ãƒ«åŸå£ã‚’ç„¡åŠ¹ï¼ˆ+100â†’0ï¼‰
            </label>
          </div>
        ` : ""}

        <div class="resultBanner">
          <div>
            <div class="winner">${escapeHtml(r.winner)}</div>
            <div class="scoreLine">é˜²è¡›ã¯åŸå£ãƒœãƒ¼ãƒŠã‚¹ï¼š${r.bonus}ï¼ˆé˜²è¡›ç´ ç‚¹ ${r.defBase}ï¼‰</div>
          </div>
          <div class="bigScore">
            <span>æ”»æ’ƒ <b>${r.atkTotal}</b></span>
            <span class="muted">vs</span>
            <span>é˜²è¡› <b>${r.defTotal}</b></span>
            <span class="pill">é˜²è¡›=${r.defBase}+${r.bonus}</span>
          </div>
        </div>
      </div>
    `;

    if(field==="ã‚»ãƒ³ãƒˆãƒ©ãƒ«"){
      const cb = card.querySelector(`#centralWallOff_${round}`);
      cb.addEventListener("change", ()=>{ state.rounds[round].fieldFlags.centralWallOff = cb.checked; save(); renderAll(); });
    }

    const grid=document.createElement("div");
    grid.className="laneGrid";

    for(const side of SIDES){
      const bucket = (side==="æ”»æ’ƒ") ? "atk" : "def";
      const lane=document.createElement("div");
      lane.className="lane";
      lane.dataset.field = field;
      lane.dataset.side = side;

      const aSum = totals[field][bucket].army;
      const pSum = totals[field][bucket].personal;

      lane.innerHTML = `
        <div class="laneTitle">
          <span>${escapeHtml(side)}</span>
          <span class="laneTotals">
            <span class="pill">è» ${aSum}</span>
            <span class="pill">ã‚­ãƒ£ãƒ© ${pSum}</span>
            <span class="pill"><b>åˆè¨ˆ ${aSum+pSum}</b></span>
          </span>
        </div>
        <div class="dropHint">${round===3 ? "ã“ã“ã«ã€Œè»ã€orã€Œã‚­ãƒ£ãƒ©ï¼ˆæ”¯æ´å«ã‚€ï¼‰ã€ã‚’ãƒ‰ãƒ­ãƒƒãƒ—" : "ã“ã“ã«ã€Œè»ã€ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆRound1/2ã¯ã‚­ãƒ£ãƒ©ä¸å¯ï¼‰"}</div>
        <div class="laneList"></div>
        <details>
          <summary class="muted">å†…è¨³</summary>
          <div class="muted" style="margin-top:6px;">
            <div><b>è»ï¼š</b>${formatArmyBreakdown(totals[field][bucket].armyBreak)}</div>
            <div style="margin-top:4px;"><b>ã‚­ãƒ£ãƒ©ï¼š</b>${formatPersonalBreakdown(totals[field][bucket].personalBreak)}</div>
          </div>
        </details>
      `;
      enableLaneDrop(lane);

      const list = lane.querySelector(".laneList");
      list.appendChild(renderPlacedArmies(field, side, snap, supportPowerBonus));
      list.appendChild(renderPlacedChars(field, side));

      grid.appendChild(lane);
    }

    card.appendChild(grid);
    board.appendChild(card);
  }
}

function finalizeRound(){
  const round = state.roundIndex;

  const preLogs = applyPreBattleLoyaltyChanges(round);
  const { results, snap, supportPowerBonus } = compute(round);
  const postLogs = applyOutcomeLoyaltyChanges(round, results);
  const occChanges = updateOccupationFromAttackWinners(round, snap, supportPowerBonus);
  const chaosLogs = applyChaosSabotageAfterWar(round, snap, supportPowerBonus);

  const lines = [...preLogs, ...postLogs, ...occChanges, ...chaosLogs];
  state.log.unshift({ round, text:`Round ${round} ç¢ºå®šï¼š${lines.join(" / ")}`, ts: monoTs() });

  save();
  renderAll();
  showPlayerResult(round, results, occChanges, chaosLogs, [...preLogs, ...postLogs]);
}

/* ========= waiting-zone drop ========= */
function setupWaitingDrops(){
  enableDropZone(el("charWaitingZone"), (payload)=>{
    const round = state.roundIndex;
    if(payload.type==="char") state.rounds[round].chars[payload.id].placed = null;
  });
  enableDropZone(el("armyWaitingZone"), (payload)=>{
    const round = state.roundIndex;
    if(payload.type==="army") state.rounds[round].armies[payload.name].placed = null;
  });
}

/* ========= Result helpers ========= */
function listSideEntities(round, field, side){
  const arr = [];
  for(const a of ARMIES){
    const p = state.rounds[round].armies[a]?.placed;
    if(p && p.field===field && p.side===side){
      arr.push({ name: getArmyDisplayName(a, round, true), rawName: a, type:"army" });
    }
  }
  if(round === 3){
    for(const c of CHAR_PRESETS){
      const p = state.rounds[round].chars[c.id]?.placed;
      if(p && p.field===field && p.side===side){
        arr.push({ name: c.supportOnly ? `${c.name}(æ”¯æ´)` : c.name, rawName: c.name, type:"char", supportOnly: !!c.supportOnly });
      }
    }
  }
  return arr;
}

function getArmyPowerForDisplay(round, armyName){
  const { snap, supportPowerBonus } = compute(round);
  const { value } = calcArmyPower(armyName, snap, round, supportPowerBonus);
  return value;
}
function getCharPowerForDisplay(round, charName){
  if(round !== 3) return 0;
  const preset = CHAR_PRESETS.find(x=>x.name===charName);
  if(!preset) return 0;
  return preset.supportOnly ? 0 : calcPersonalPower(preset);
}

function buildSideListHtml(round, field, side){
  const entities = listSideEntities(round, field, side);
  const rows = entities.map(e=>{
    const p = (e.type==="army") ? getArmyPowerForDisplay(round, e.rawName) : getCharPowerForDisplay(round, e.rawName);
    return { name:e.name, power:p };
  }).sort((a,b)=>b.power-a.power);

  const sum = rows.reduce((s,x)=>s+x.power,0);

  const cls = (side==="æ”»æ’ƒ") ? "atk" : "def";
  const sideLabel = (side==="æ”»æ’ƒ") ? "æ”»æ’ƒå´" : "é˜²è¡›å´";

  const box = document.createElement("div");
  box.className = `res-sideBox ${cls}`;
  box.innerHTML = `
    <div class="t">
      <span>${sideLabel}</span>
      <span>åˆè¨ˆ <b>${sum}</b></span>
    </div>
    <div>
      ${rows.length ? rows.map(r=>`
        <div class="res-line">
          <span class="nm">${escapeHtml(r.name)}</span>
          <span class="pv">${r.power}</span>
        </div>
      `).join("") : `<div class="muted tiny">ï¼ˆãªã—ï¼‰</div>`}
    </div>
  `;
  return box;
}

/* ========= Player UI Modal ========= */
function showPlayerResult(round, results, occupationChanges, chaosLogs, loyaltyLogs){
  const grid = document.getElementById("resGrid");
  grid.innerHTML = "";
  document.getElementById("resRoundNum").textContent = round;

  // ã“ã“ã§ "ã‚»ãƒ³ãƒˆãƒ©ãƒ«â†’ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼â†’ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰â†’é‡‘è¯" ã®é †ã«å›ºå®š
  const order = ["ã‚»ãƒ³ãƒˆãƒ©ãƒ«","ã‚µã‚¦ã‚¹ãƒªãƒãƒ¼","ãƒãƒ¼ã‚¹ãƒ©ãƒ³ãƒ‰","é‡‘è¯"];
  const resultsOrdered = order.map(f=>results.find(x=>x.field===f)).filter(Boolean);

  const deserters = (loyaltyLogs||[]).filter(x=>String(x).includes("ğŸ’¥è„±èµ°"));
  const healers   = (loyaltyLogs||[]).filter(x=>String(x).includes("âœ¨å…µåŠ›å›å¾©"));
  const freeJoiners = (loyaltyLogs||[]).filter(x=>String(x).includes("ğŸ•Šï¸è‡ªç”±ã®åŒå¿—ï¼š"));

  resultsOrdered.forEach(r => {
    const isAtkWon = (r.atkTotal > r.defTotal);
    const fieldKey = FIELD_TO_COLORKEY[r.field];

    const occChange = occupationChanges.find(c => c.includes(r.field) && c.includes("å æ‹ æ›´æ–°"));
    const currentOcc = state.occupation[r.field] || "-";

    const total = Math.max(1, r.atkTotal + r.defTotal);
    const atkPct = Math.round((r.atkTotal / total) * 100);
    const defPct = 100 - atkPct;

    const div = document.createElement("div");
    div.className = `res-card ${isAtkWon ? "atk-win" : "def-win"}`;

    div.innerHTML = `
      <div class="res-header">
        <span><span class="dot ${fieldKey}"></span> ${escapeHtml(FIELD_LABEL[r.field] || r.field)}</span>
        <span class="pill">å æ‹ : ${escapeHtml(currentOcc)}</span>
      </div>

      <div class="res-scores">
        <span style="color:var(--atk)">${r.atkTotal}</span>
        <span class="res-vs">vs</span>
        <span style="color:var(--def)">${r.defTotal}</span>
      </div>

      <div class="muted tiny" style="text-align:center">
        (é˜²è¡›ç´ ç‚¹ ${r.defBase} + åŸå£ ${r.bonus})
      </div>

      <div class="gaugeWrap" aria-label="å‹æ•—ã‚²ãƒ¼ã‚¸">
        <div class="gAtk" style="width:${atkPct}%"></div>
        <div class="gDef" style="width:${defPct}%"></div>
      </div>
      <div class="gLabelRow">
        <span>æ”»æ’ƒ <b>${atkPct}%</b></span>
        <span>é˜²è¡› <b>${defPct}%</b></span>
      </div>
      <div class="gMini">â€»æ¯”ç‡è¡¨ç¤ºï¼ˆåˆè¨ˆå€¤ã«å¯¾ã™ã‚‹å‰²åˆï¼‰</div>

      <div class="res-ribbon ${isAtkWon ? "atk" : "def"}">
        <span>${isAtkWon ? "âš”ï¸ æ”»æ’ƒå‹åˆ©ï¼" : "ğŸ›¡ï¸ é˜²è¡›æˆåŠŸï¼"}</span>
        <span>${isAtkWon ? "æ”»æ’ƒå´ãŒæŠ¼ã—åˆ‡ã£ãŸ" : "é˜²è¡›å´ãŒå®ˆã‚Šåˆ‡ã£ãŸ"}</span>
      </div>

      <div class="res-sideLists" id="sideLists_${cssEscape(r.field)}"></div>

      <div class="stamp ${isAtkWon ? "st-win" : "st-lose"}">
        ${isAtkWon ? "ATTACK WIN" : "DEFENDED"}
      </div>

      ${occChange ? `<div class="res-alert">âš ï¸ å æ‹ è€…ãŒå¤‰ã‚ã‚Šã¾ã—ãŸï¼</div>` : ""}
    `;

    const lists = div.querySelector(`#sideLists_${cssEscape(r.field)}`);
    lists.appendChild(buildSideListHtml(round, r.field, "æ”»æ’ƒ"));
    lists.appendChild(buildSideListHtml(round, r.field, "é˜²è¡›"));

    const gAtk = div.querySelector(".gAtk");
    const gDef = div.querySelector(".gDef");
    if(isAtkWon) gAtk.classList.add("winStretch");
    else gDef.classList.add("winStretchRight");

    grid.appendChild(div);
  });

  // ãƒ‹ãƒ¥ãƒ¼ã‚¹æ¬„ï¼ˆæå†™ï¼‰
  const newsBox = document.getElementById("resNews");
  newsBox.innerHTML = "";

  if(occupationChanges.length > 0){
    const blk = document.createElement("div");
    blk.className="newsBlock";
    blk.innerHTML = occupationChanges.map(t=>`<div><b>ã€é€Ÿå ±ã€‘</b> ${escapeHtml(t)}</div>`).join("");
    newsBox.appendChild(blk);
  }

  // è„±èµ°ï¼šæå†™ã‚’ã€Œè‡ªç”±ã®æ©Ÿé‹ãŒé«˜ã¾ã£ã¦ã„ã‚‹ã€
  if(deserters.length){
    const box = document.createElement("div");
    box.className="newsBoom";
    box.innerHTML = `
      <div class="hd">ğŸ’¥ å…µã®è„±èµ°ãŒç™ºç”Ÿï¼</div>
      <div class="li"><b>ã€æƒ…å‹¢ã€‘</b> è‡ªç”±ã®æ©Ÿé‹ãŒé«˜ã¾ã‚Šã€å‰ç·šã®çµ±åˆ¶ãŒæºã‚‰ã„ã§ã„ã‚‹ã€‚å‘½ä»¤ç³»çµ±ã¯ä¹±ã‚Œã€å…µã¯éšŠã‚’é›¢è„±ã—å§‹ã‚ãŸã€‚</div>
      ${deserters.slice(0,12).map(t=>`<div class="li">${escapeHtml(t)}</div>`).join("")}
      ${deserters.length>12 ? `<div class="li muted">â€¦ä»– ${deserters.length-12} ä»¶</div>` : ``}
    `;
    newsBox.appendChild(box);
  }

  if(freeJoiners.length){
    const box = document.createElement("div");
    box.className="newsSab";
    box.innerHTML = `
      <div class="hd">ğŸ•Šï¸ è‡ªç”±ã®åŒå¿—ãŒåˆæµ</div>
      <div class="li"><b>ã€æƒ…å‹¢ã€‘</b> é–ã‚’æ–­ã¡åˆ‡ã£ãŸè€…ãŸã¡ãŒâ€œãƒªãƒ™ãƒ¬ãƒ¼ã‚¿ãƒ¼åŒå¿—â€ã¸èº«ã‚’æŠ•ã˜å§‹ã‚ãŸã€‚å‰ç·šã®å™‚ã¯ä¸€æ°—ã«åºƒãŒã£ã¦ã„ã‚‹ã€‚</div>
      ${freeJoiners.map(t=>`<div class="li">${escapeHtml(t)}</div>`).join("")}
    `;
    newsBox.appendChild(box);
  }

  if(healers.length){
    const box = document.createElement("div");
    box.className="newsBoom";
    box.style.borderColor = "rgba(34,197,94,.35)";
    box.style.background = "rgba(34,197,94,.08)";
    box.innerHTML = `
      <div class="hd" style="color:#15803d;">âœ¨ å…µåŠ›å›å¾©ãŒç™ºç”Ÿï¼</div>
      <div class="li"><b>ã€æƒ…å‹¢ã€‘</b> å£«æ°—ãŒæŒã¡ç›´ã—ã€é›¢è„±ã—ã¦ã„ãŸå…µãŒéƒ¨éšŠã¸æˆ»ã‚Šå§‹ã‚ãŸã€‚è£œçµ¦ç·šã‚‚ã‹ã‚ã†ã˜ã¦ç¶­æŒã•ã‚Œã¦ã„ã‚‹ã€‚</div>
      ${healers.slice(0,12).map(t=>`<div class="li">${escapeHtml(t)}</div>`).join("")}
      ${healers.length>12 ? `<div class="li muted">â€¦ä»– ${healers.length-12} ä»¶</div>` : ``}
    `;
    newsBox.appendChild(box);
  }

  if(chaosLogs && chaosLogs.length > 0){
    const box = document.createElement("div");
    box.className="newsSab";
    box.innerHTML = `
      <div class="hd">ğŸ•µï¸ æš—èºï¼šç ´å£Šå·¥ä½œ</div>
      <div class="li"><b>ã€æƒ…å‹¢ã€‘</b> é™£åœ°ã®èƒŒå¾Œã§ä¸å¯©ãªå‹•ããŒç¢ºèªã•ã‚ŒãŸã€‚è£œçµ¦ã¨é€šä¿¡ã«ç¶»ã³ãŒç”Ÿã˜ã¦ã„ã‚‹ã€‚</div>
      ${chaosLogs.map(t=>`<div class="li">${escapeHtml(t)}</div>`).join("")}
    `;
    newsBox.appendChild(box);
  }

  if(!occupationChanges.length && (!chaosLogs || !chaosLogs.length) && !deserters.length && !healers.length){
    newsBox.textContent = "ç‰¹ç­†ã™ã¹ãæˆ¦å¾Œå¤‰å‹•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚";
  }

  document.getElementById("resultOverlay").style.display = "flex";
}

/* ========= close & save result ========= */
function closeResult(){ document.getElementById("resultOverlay").style.display = "none"; }

function saveResultAsHtml(){
  const modal = document.getElementById("resultModalRoot");
  const html = `
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>æˆ¦æœå ±å‘Šæ›¸ï¼ˆä¿å­˜ï¼‰</title>
<style>${document.querySelector("style").textContent}</style>
</head>
<body style="margin:18px;background:#fafafa;">
<div class="resultModal" style="max-height:none; overflow:visible;">
${modal.innerHTML}
</div>
</body>
</html>`.trim();

  const blob = new Blob([html], {type:"text/html"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `regastria_result_round${document.getElementById("resRoundNum").textContent}.html`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

/* ========= renderAll ========= */
function renderAll(){
  renderTop();
  renderWaitingArmies();
  renderWaitingChars();
  renderBoard();
}

/* ========= buttons ========= */
el("btnFinalizeRound").addEventListener("click", ()=>{
  if(!confirm(`Round ${state.roundIndex} ã‚’ç¢ºå®šã—ã¾ã™ã€‚\nå¿ èª å¿ƒâ†’å…µåŠ›å¢—æ¸›â†’å‹æ•—â†’å æ‹ /ç ´å£Šå·¥ä½œ ã‚’é©ç”¨ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) return;
  finalizeRound();
});
el("btnPrevRound").addEventListener("click", ()=>{ state.roundIndex = Math.max(1, state.roundIndex - 1); save(); renderAll(); });
el("btnNextRound").addEventListener("click", ()=>{ state.roundIndex = Math.min(MAX_ROUNDS, state.roundIndex + 1); save(); renderAll(); });
el("btnClearChars").addEventListener("click", ()=>{ const round = state.roundIndex; for(const p of CHAR_PRESETS) state.rounds[round].chars[p.id].placed=null; save(); renderAll(); });
el("btnClearArmies").addEventListener("click", ()=>{ const round = state.roundIndex; for(const name of ARMIES) state.rounds[round].armies[name].placed=null; save(); renderAll(); });
el("btnResetAll").addEventListener("click", ()=>{ if(!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ï¼ˆå æ‹ ãƒ»å…µåŠ›ãƒ»å¿ èª å¿ƒãƒ»é…ç½®ãƒ»ãƒ­ã‚°ï¼‰ã‚’æ¶ˆå»ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return; localStorage.removeItem(STORAGE_KEY); initDefaults(); save(); renderAll(); });
el("btnSaveResultHtml").addEventListener("click", saveResultAsHtml);

/* ========= init ========= */
load();
setupWaitingDrops();
renderAll();
</script>
</body>
</html>

